\section{Cardiac Simulation Toolkit}

Extracting results from cardiac modeling requires a computational implementation
of a cardiac model and then to drive this model through an experimental
protocol.
A cardiac simulation toolkit provides an implementation of the model, or models,
and a way of driving them to produce results.
In this way, they can simplify research for the investigator, saving time and
effort of programming oneself.


\subsection{Advantages of Cardiac Simulation Toolkits}

Toolkits can be an attractive option for cardiac investigators.
The most obvious benefit is intrinsic in the nature of toolkits--the
investigator need not implement a potentially complex model themselves.
This saves effort both in the initial programming and also in the subsequent
validation of the model which is essential for ensuring an accurate model has
been created.
This can also reduce the need for boring and repetitive programming.
It can also open up the field of cardiac modeling to those without programming
experience, such as physiologists and physicians, allowing them to contribute
their experience and opinions to the field.

Because a toolkit is intended to be used many times, it can be more feasible to
incorporate more advanced techniques.
These can include advanced solvers for ODEs and PDEs.
The pay off for optimisation can also be higher.

There are also benefits in consistency, both within and outside the research
group.
This allows for easier comparison of results between separate studies and
quicker checking for errors.
This can be especially significant in large-scale models.

\subsection{Disadvantages of Cardiac Simulation Toolkits}

Toolkits are not without problems, however.
Some of these problems might be implementation specific, but many cannot be
entirely avoided.
They can roughly be divided into usage problems and extension problems.
Usage problems concern the day-to-day usage of the toolkit, whilst extension
problems deal with the issue of making the toolkit do more.

One problem can be the complexity of the toolkit itself.
Complexity can make toolkits hard, even intimidating to use.
This can be mitigated through good documentation and logical layout.

A second problem is one of platform dependency.
A toolkit might rely on features only available on one platform or only be
available in binary packages for that one platform.
This can be especially important when the time comes to extend into a high
performance computing environment, which can often be based on a different
architecture and platform to local resources.

A third problem, which is mostly implementation dependent, is one of
configuration and output.
Toolkits, especially those with graphical interfaces, can often only be setup
through such interfaces.
This can make setting up experiments with small variations tedious.
The output can also be in a format which is only easily read by the toolkit
itself, tying a user to the toolkit.

Bugs can be present in both toolkit code and bespoke code.
Whilst the nature of toolkits can result in such a bug being found sooner, the
bug has a potential to influence many studies if the toolkit is widely used.
This can obviously be mitigated through appropriate testing.

Another problem can be one of `design impedance', which can also be expressed as
`When all you have is a hammer, every problem looks like a nail'.
Toolkits tend to present an easy or preferred path for modeling studies.
This can make deviations from this path, even when they might be advisable for
physiological considerations, harder.

Moving on from usage considerations, extension problems can also be significant.
Closely related to design impedance is the difficulty toolkits can present in
extension.
If the toolkit is closed source, this is impossible, or nearly so.
In addition, the internal complexity of a toolkit can make additions in open
source implementations difficult.

\subsection{Available Toolkits}

There are several available toolkits, of differing scales and intended uses.
These represent the different intents of the authors and contributors.

\subsubsection{CellML}

Whilst not a toolkit in its own right, the CellML repository, curated by the
University of Auckland~\cite{Lloyd2008}, represents a potentially useful
resource for all cardiac modelers.
Using an XML based markup language, CellML, the CellML repository contains
representations of many electrophysiology models.
From these XML documents, programs can create code to solve the system of
equations representing the cellular model.
Once a translator has been implemented, any model in CellML format should be
easy to simulate.

CellML is used as a model input format for several toolkits.
CellML suffers from two problems.
The first is that writing complex mathematics for ionic channel function can be
difficult in the XML based format.
The second is that the API itself for translating the CellML code into a form
which is possible to compile is also complex, although this problem need only be
solved once for any given toolkit.


\subsubsection{Cardiac Arrhythmia Research Package}

The Cardiac Arrhythmia Research Package~\cite{Bauer2007,Plank2005,Vigmond2007}\
(CARP) is a sophisticated library for large scale cardiac modeling.
It is developed by Dr. Edward Vigmond and Dr. Gernot Plank.
It is mostly implemented in C/++.

The CARP is intended to be a powerful and flexible cardiac simulation library.
It is organised into three layers.
The application layer is very high level and is intended to be mostly free of
the complexities of the underlying model and parallelisation.
The interface layer deals with the complexities of parallelization and
distributing cellular models over the grid.
The ionic layer has all the individual cell models, which again requires no
knowledge of parallelization.

The CARP can handle both structured and unstructured input grids and can also
perform dynamic grid refinement.
The API provided by the toolkit is quite clean and provides access to powerful
techniques to solve large systems.
The CARP doesn't currently support CellML model input.


\subsubsection{CMISS}

CMISS is a toolkit for solving problems in Continuum Mechanics, Image analysis,
Signal processing and System Identification.
It is developed by a group at the University of Auckland~\cite{CMISS}.
The CMISS package is a collection of programs and libraries for solving a
variety of problems, including electrophysiology.
It is implemented principally in Fortran.
A compiled version is freely available from the project website, for linux only.

CMISS supports importing models from CellML.
It includes quite powerful visualization capabilities in addition to the
modelling capabilities it offers.
The modelling implementation includes a variety of solvers for both ODE and
PDEs.

CMISS is complex enough that it has its own language for configuration files
which define the problem to solve.
In addition several configuration files are needed to define one problem.
It also outputs results in its own format, which can make interoperability
with different visualisation difficult.

\subsubsection{Cellular Open Resource}

The Cellular Open Resource (COR)~\cite{Garney2003}\ is intended for single cell
modeling.
It is freely available from the website, for windows only.
It is allows editing of CellML files and execution of the models using a variety
of integrators.
The COR can provide tracings of all currents and state variables as the action
potential evolves.
It also supports exporting models to a variety of formats, including C and
Fortran.

The COR is single cell only, and only works on windows.
The source code is not publicly available meaning that extension other than
modifying models is not possible.
Modification of models and specification of stimulus protocols is via its own
programming language or direct modification of XML files.
